const assert = require('assert');
const TypeCheck = require('js-typecheck');


// symbols used for private instance variables to avoid any potential clashing
// caused by re-implementations
const _inputName = Symbol('inputName');
const _code = Symbol('code');

/**
 * Exception generated by input validations
 *
 * It carries additional information about the context of the error that can be used when
 * reporting/handling it. For this reason when this exception is raised through {@link RequestHandler}
 * the contents are encoded into json {@link toJson}
 *
 * ```javascript
 * throw new ValidationError('File does not exit!')
 * ```
*/
class ValidationError extends Error{

  /**
   * Initialize the exception
   *
   * @param {string} message - error message
   * @param {string} [code] - unique code based on uuid v4 that can be used to identify the error
   * @param {string} [inputName] - name of the input about where the exception was generated
   * type
   */
  constructor(message, code=null, inputName=null){
    assert(TypeCheck.isString(message) && message.length, 'message needs to defined as valid string (cannot be empty)');
    super(message);

    this.code = code;
    this.inputName = inputName;
  }

  /**
   * Sets the input name related with the validation
   *
   * @param {string} [inputName] - name of the input
   */
  set inputName(inputName){
    assert(inputName === null || (TypeCheck.isString(inputName) && inputName.length), 'inputName needs to defined as valid string');

    this[_inputName] = inputName;
  }

  /**
   * Returns the input name related with the validation
   *
   * @type {string}
   */
  get inputName(){
    return this[_inputName];
  }

  /**
   * Sets an unique error code related with the validation, this can be used to identify
   * the error type
   *
   * @param {string} [errorCode] - unique code based on uuid v4 that can be used to identify the error
   */
  set code(errorCode){
    assert(errorCode === null || /^\w{8}-\w{4}-\w{4}-\w{4}-\w{12}$/.test(errorCode), 'errorCode needs to defined as uuid or null');

    this[_code] = errorCode;
  }

  /**
   * Returns the validation error code
   *
   * @type {string}
   */
  get code(){
    return this[_code];
  }

  /**
   * Bakes the exception into a json string
   *
   * @return {string} json string containing the serialized version of the exception
   */
  toJson(){
    return JSON.stringify({
      message: this.message,
      code: this.code,
      inputName: this.inputName,
    });
  }

  /**
   * Creates a ValidationError instance based on the input json string
   *
   * @param {string} json - string containing the serialized json version of the exception
   * @return {Object}
   */
  static fromJson(json){
    assert(TypeCheck.isString(json) && json.length, 'json needs to be defined as valid string');

    const data = JSON.parse(json);
    return new ValidationError(data.message, data.code, data.inputName);
  }
}

module.exports = ValidationError;
