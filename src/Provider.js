const assert = require('assert');
const TypeCheck = require('js-typecheck');
const EventEmitter = require('events');
const Settings = require('./Settings');
const Action = require('./Action');
const Session = require('./Session');
const RequestHandler = require('./RequestHandler');


// symbols used for private instance variables to avoid any potential clashing
// caused by re-implementations
const _session = Symbol('session');

/**
 * Provides an interface to register and create actions
 *
 * It works by grouping actions that are about the same context inside of the
 * same provider. Usually an {@link action} is registered just for
 * a single provider. However you are able to register it ({@link registerAction})
 * for as many providers as you want. Registered actions are available through
 * the provider inheritance which means when looking for an action it looks in all
 * of the parent classes as well.
 *
 * By registering actions ({@link registerAction}) to providers they can be executed
 * through requests ({@link webfyProvider}, {@link webfyAction}), following:
 * `https://.../<providerRoute>/<actionRoute>`
 *
 * Also, you can execute actions from providers by creating providers through {@link create},
 * then creating the action through {@link createAction}:
 *
 * ```javascript
 * // implementing a custom provider
 * class SomeProvider extends Provider {
 * }
 *
 * // registering the provider
 * Provider.registerProvider(SomeProvider);
 *
 * // webfying the provider
 * Provider.webfyProvider(SomeProvider);
 * ```
 *
 * ```javascript
 * // creating the provider
 * let someProvider = Provider.create('SomeProvider');
 *
 * // creating an action that is registered for the provider
 * let getBeer = someProvider.createAction('GetBeer');
 *
 * // customizing the action
 * getBeer.input('style').value = 'IPA';
 *
 * // executing the action (promise based)
 * getBeer.execute().then(...);
 * ```
 */
class Provider{

  /**
   * Creates a provider
   *
   * @param {Session} session - session object
   */
  constructor(session){
    assert(!TypeCheck.isNone(session), 'Session not specified!');
    assert(TypeCheck.isInstanceOf(session, Session), 'Invalid session!');

    this[_session] = session;
  }

  /**
   * Returns the session
   *
   * @type {Session}
   */
  get session(){
    return this[_session];
  }

  /**
   * Returns the registered action names for the current provider
   *
   * @return {Array<string>}
   */
  get actionNames(){
    const ProviderClass = this.constructor;
    return Object.keys(ProviderClass._providerActions(ProviderClass));
  }

  /**
   * Factories an action based on the input action name, in case the action does
   * not exist a null is returned instead
   *
   * @param {string} actionName - registered action name
   * @return {Action|null}
   */
  createAction(actionName){
    assert(TypeCheck.isString(actionName), 'Action name needs to be defined as string');

    const actionHolder = this.constructor._actionHolder(actionName);
    if (actionHolder){
      const action = new actionHolder.action(); // eslint-disable-line new-cap
      action.session = this.session;

      // adding the info to the action
      for (const infoName in actionHolder.info){
        action.info[infoName] = Object.freeze(actionHolder.info[infoName]);
      }

      return action;
    }

    return null;
  }

  /**
   * Factories an action based on the serialized input which is generated by
   * {@link Action.toJson}
   *
   * @param {string} serializedAction - json encoded action
   * @return {Action|null}
   */
  static createActionFromJson(serializedAction){
    assert(TypeCheck.isString(serializedAction), 'serializedAction needs to be defined as string!');

    const actionContents = JSON.parse(serializedAction);
    const providerName = actionContents.info.providerName;
    const actionName = actionContents.info.actionName;

    const ProviderClass = this.registeredProvider(providerName);
    assert(ProviderClass, `Provider not found: ${providerName}`);

    const session = new Session(null, actionContents.session.autofill);
    const action = new ProviderClass(session).createAction(actionName);
    assert(action, `Action not found: ${providerName}/${actionName}`);

    for (const inputName in actionContents.inputs){
      const input = action.input(inputName);
      assert(input, `Input not found: ${providerName}/${actionName}/${inputName}`);
      input.parseValue(actionContents.inputs[inputName]);
    }

    return action;
  }

  /**
   * Register an action to a provider
   *
   * This makes the action available under the provider. Actions are created through
   * {@link createAction}
   *
   * Alternatively this method can be called directly from Oca as `Oca.registerAction(...)`
   *
   * @emits `registerAction` event emitted passing the `providerName` and `actionName`
   *
   * @param {string|Provider} providerClassOrName - provider class or registered provider name
   * @param {Action} actionClass - action that should be registered under the provider
   * @param {string} [name] - action name, if none is specified
   * it will use the name of the action class
   */
  static registerAction(providerClassOrName, actionClass, name=''){
    assert(TypeCheck.isSubClassOf(actionClass, Action), 'actionClass needs to be derived from Action!');
    assert(TypeCheck.isString(name), 'optional name needs to be defined as string!');

    const nameFinal = (name === '') ? actionClass.name : name;

    // validating action name
    assert((/^([\w_\.\-])+$/gi).test(nameFinal), `Invalid action name: ${nameFinal}`); // eslint-disable-line no-useless-escape

    const registeredProviderName = this._resolveProviderName(providerClassOrName);
    assert(registeredProviderName, 'provider not found, is it registered?');

    if (!(registeredProviderName in this._actions)){
      this._actions[registeredProviderName] = {};
    }

    this._actions[registeredProviderName][nameFinal] = {
      action: actionClass,
      info: {
        requestMethod: RequestHandler.Method.None,
        requestAuth: false,
        providerName: registeredProviderName,
        actionName: nameFinal,
      },
    };

    // emitting a signal about the new action
    this._eventEmitter.emit('registerAction', registeredProviderName, nameFinal);
  }

  /**
   * webfy an action
   *
   * This makes an action available for requests ({@link restful} and {@link middleware})
   *
   * Alternatively this method can be called directly from Oca as `Oca.webfyAction(...)`
   *
   * @emits `webfyAction` event emitted passing the `providerName`, `actionName`, `requestMethod`
   * , `auth`, `rest` and `restRoute`
   *
   * @param {string|Provider} providerClassOrName - provider class or registered provider name
   * @param {Action|string} actionClassOrName - action class or registered action name
   * @param {Enum} requestMethod - tells the request method about how the action should
   * be available, possible values: `Oca.Method.Get`, `Oca.Method.Post`,
   * `Oca.Method.Put`, `Oca.Method.Delete` and `Oca.Method.None`
   * @param {Object} options - custom options
   * @param {boolean} [options.auth=false] - tells if the request requires authorization
   * @param {boolean} [options.rest=true] - tells if the action will be visible through
   * {@link restful}, otherwise it can only be accessed through a {@link middleware}
   * @param {string} [options.restRoute] - action rest route path, by default it uses the action name.
   * This route gets concatenated with the provider route automatically
   */
  static webfyAction(providerClassOrName=this, actionClassOrName, requestMethod, {auth=false, rest=true, restRoute=null}={}){
    assert((actionClassOrName !== Action && TypeCheck.isSubClassOf(actionClassOrName, Action)) || TypeCheck.isString(actionClassOrName),
    'action needs to be defined as valid string or Action class!');
    assert(TypeCheck.isNumber(requestMethod), 'requestMethod needs to be defined as numerically!');
    assert(TypeCheck.isBool(auth), 'auth needs to be defined as boolean');
    assert(TypeCheck.isBool(rest), 'rest needs to be defined as boolean');
    assert(restRoute === null || TypeCheck.isString(restRoute), 'restRoute needs to be defined as string or null');

    const providerName = this._resolveProviderName(providerClassOrName);
    assert(providerName, 'provider not found, is it registered?');

    const actionName = (TypeCheck.isSubClassOf(actionClassOrName, Action)) ? actionClassOrName.name : actionClassOrName;

    let restRouteFinal = (restRoute === null) ? actionName : restRoute;
    if (!restRouteFinal.startsWith('/')){
      restRouteFinal = `/${restRouteFinal}`;
    }

    // validating restRoute
    assert((/^([\w_\/\.\-])+$/gi).test(restRouteFinal), `Invalid action restRoute: ${restRouteFinal}`); // eslint-disable-line no-useless-escape

    if (providerName in this._actions && actionName in this._actions[providerName]){
      this._actions[providerName][actionName].info.requestMethod = requestMethod;
      this._actions[providerName][actionName].info.requestAuth = auth;
      this._actions[providerName][actionName].info.restRoute = restRouteFinal;
      this._actions[providerName][actionName].info.restVisibility = rest;
    }
    else{
      throw new Error('Action not registered!');
    }

    // updating the routes in case the load has been already called previously
    this._clearRoutesPathCache();

    // emitting a signal about the new route
    this._eventEmitter.emit('webfyAction', providerName, actionName, requestMethod, auth, rest, restRouteFinal);
  }

  /**
   * Register a route for a provider
   *
   * This makes a provider available for requests, by doing it actions that were
   * webfied ({@link webfyAction}) will be immediately available for requests
   * the provider route, for the rest path instance: `https://.../<providerRoute>/<actionRoute>`
   *
   * Alternatively this method can be called directly from Oca as `Oca.webfyProvider(...)`
   *
   * @emits `webfyProvider` event emitted passing the `providerName` and restRoute
   *
   * @param {string|Provider} providerClassOrName - provider class or registered provider name
   * @param {Object} options - custom options
   * @param {string} [options.restRoute] - route path to access the provider (for instance: `/MyProviderRoute`)
   * by the {@link restful}, in case it is not defined then it uses the provider name
   */
  static webfyProvider(providerClassOrName, {restRoute=null}={}){
    const providerName = (TypeCheck.isSubClassOf(providerClassOrName, Provider)) ? providerClassOrName.name : providerClassOrName;
    assert(this.registeredProvider(providerName), 'provider not registered!');

    let restRouteFinal = (restRoute === null) ? providerName : restRoute;
    assert(TypeCheck.isString(restRouteFinal) && restRouteFinal.length, 'restRoute needs to be defined as valid string!');

    if (!restRouteFinal.startsWith('/')){
      restRouteFinal = `/${restRouteFinal}`;
    }

    // validating route
    assert((/^([\w_\/\.\-])+$/gi).test(restRouteFinal), `Invalid provider route: ${restRouteFinal}`); // eslint-disable-line no-useless-escape

    // checking if the route has already been registered for a different provider,
    // if so, overriding it
    for (const registeredProviderName in this._webfyProviders){
      if (this._webfyProviders[registeredProviderName] === restRouteFinal){
        delete this._webfyProviders[registeredProviderName];
        break;
      }
    }

    this._webfyProviders[providerName] = restRouteFinal;

    // updating the routes in case the load has been already called previously
    this._clearRoutesPathCache();

    // emitting a signal about the new restRoute
    this._eventEmitter.emit('webfyProvider', providerName, restRouteFinal);
  }

  /**
   * Called by the express server to handle a request
   * through Oca. This method should return an instance of the
   * request handler which is used to interface the request.
   *
   * @return {RequestHandler}
   */
  requestHandler(){
    return new RequestHandler(this.session);
  }

  /**
   * Register a provider to the available providers
   *
   * Alternatively this method can be called directly from Oca as `Oca.registerProvider(...)`
   *
   * @emits `registerProvider` event emitted passing the `providerName`
   *
   * @param {Provider} providerClass - provider class
   * @param {name} [name] - registration name, if none is specified
   * it will use the name of the class
   */
  static registerProvider(providerClass, name=''){
    assert(TypeCheck.isSubClassOf(providerClass, Provider), 'Invalid Provider type!');
    assert(TypeCheck.isString(name), 'Invalid optional registration name!');
    assert(Provider !== providerClass, 'Cannot register base class!');

    // flushing the class hierarchy cache
    this._classHierarchy = {};

    const nameFinal = (name === '') ? providerClass.name : name;

    // validating name
    assert((/^([\w_\.\-])+$/gi).test(nameFinal), `Invalid provider name: ${nameFinal}`); // eslint-disable-line no-useless-escape

    // making sure the input provider has not been already registered with a different
    // name which would lead to ambiguity when resolving the type to the name. Therefore
    // the relation between providerName and providerType should be one to one.
    if (providerClass in this._registeredProviderTypes && nameFinal !== this._registeredProviderTypes[providerClass]){
      throw new Error(`Cannot register type, it is already registered as: ${this._registeredProviderTypes[providerClass]}`);
    }

    this._registeredProviderNames[nameFinal] = providerClass;
    this._registeredProviderTypes[providerClass] = nameFinal;

    // emitting a signal about the new provider
    this._eventEmitter.emit('registerProvider', nameFinal);
  }

  /**
   * Returns a boolean telling the input provider name is registered
   *
   * @param {string} name - registered provider name
   * @return {string|null}
   */
  static registeredProvider(name){
    if (name in this._registeredProviderNames){
      return this._registeredProviderNames[name];
    }
    return null;
  }

  /**
   * Returns the list of the registered provider names
   *
   * @type {Array<string>}
   */
  static get registeredProviderNames(){
    return Object.keys(this._registeredProviderNames);
  }

  /**
   * Factories a provider based on the registered input name
   *
   * Alternatively this method can be called directly from Oca as `Oca.createProvider(...)`
   *
   * @param {string} name - registered provider name
   * @param {...*} args - arguments passed to the construction of the instance
   * @return {Provider}
   */
  static create(name, ...args){
    const ProviderClass = this.registeredProvider(name);

    // creates a new instance
    if (!ProviderClass){
      throw new Error(`Provider: ${name}, is not registered!`);
    }

    return new ProviderClass(...args);
  }

  /**
   * Returns a middleware designed to execute a webfied {@link Action} based on
   * an arbitrary express route. Differently from {@link restful} this method
   * does not response the request, instead it's done through the responseCallback
   * which passes the action error, result and the default middleware express
   * arguments
   *
   * ```javascript
   * const app = express();
   * app.get(
   *  '/sum',
   *  Provider.middleware('SomeProvider/Sum', (err, result, req, res, next) => {
   *    ...
   *  })
   * )
   * ```
   *
   * Alternatively this method can be called directly from Oca
   * ```javascript
   * const app = express();
   * app.get(
   *  '/sum',
   *  Oca.middleware('SomeProvider/Sum', (err, result, req, res, next) => {
   *    ...
   *  })
   * )
   * ```
   *
   * @param {string} actionLocation - String containing the registered provider name
   * and the registered action name separated by '/' about which action should
   * executed when the route is requested, for instance: 'Provider/Action'
   * @param {function} [responseCallback] - optional response callback that overrides
   * the default json response. The callback carries the express:
   * function(err, result, req, res, next){...}
   * @return {function}
   */
  static middleware(actionLocation, responseCallback){
    const actionParts = actionLocation.split('/');
    assert.equal(actionParts.length, 2, `Invalid action location format '${actionLocation}', expected 'ProviderName/ActionName'`);

    const providerName = actionParts[0];
    const actionName = actionParts[1];
    const providerRoute = this._webfyProviders[providerName];

    assert(providerRoute, `Could not get the route for the provider: ${providerName}`);

    return this._createMiddleware(providerName, actionName, false, responseCallback);
  }

  /**
   * Returns a callback that is used by the express app to handle routes
   * from webfied visible actions ({@link webfyProvider} & {@link webfyAction}).
   * They are available under:
   * `<ProviderRoute>/<ActionRoute>`. When an action is executed through
   * this method it automatically responses the request, further details
   * can be found at {@link RequestHandler.render}
   *
   * ```javascript
   * expressApp.use(Provider.restful())
   * ```
   *
   * Alternatively this method can be called directly from Oca
   * ```javascript
   * expressApp.use(Oca.restful())
   * ```
   *
   * @param {function} [authenticate] - Passport authenticate middleware
   * which is used when an {@link Action} requires authentication, this
   * method sets the authentication the value under {@link Settings.authentication}
   * @return {function}
   */
  static restful(authenticate=null){
    if (authenticate !== null){
      Settings.authenticate = authenticate;
    }

    return (req, res, next) => {
      // building the cache
      if (Object.keys(this._routesPathCache).length === 0){
        // registering the routes
        for (const providerName in this._webfyProviders){
          const providerClass = this.registeredProvider(providerName);
          const actions = this._providerActions(providerClass);
          const providerRoute = this._webfyProviders[providerName];

          assert(providerRoute, `Could not get the route for the provider: ${providerName}`);

          for (const actionName in actions){
            if (actions[actionName].info.requestMethod !== RequestHandler.Method.None){
              const actionRoute = actions[actionName].info.restRoute;
              const routePath = `${providerRoute}${actionRoute}`;
              this._routesPathCache[routePath] = this._createMiddleware(providerName, actionName, true);
            }
          }
        }
      }

      // executing the middleware
      if (req.path in this._routesPathCache){
        this._routesPathCache[req.path](req, res, next);
      }
      else{
        next();
      }
    };
  }

  /**
   * Adds a listener for the input event name that is available for the
   * registration and webfy methods
   *
   * @param {string} eventName - name of the signal
   * @param {function} listener - slot executed when the signal is emitted
   */
  static on(eventName, listener){
    this._eventEmitter.on(eventName, listener);
  }

  /**
   * Auxiliary method that resolves the provider name
   *
   * @param {Provider|string} providerClassOrName - provider class or registered
   * provider name
   *
   * @return {string}
   * @private
   */
  static _resolveProviderName(providerClassOrName){
    let providerName = null;

    if (TypeCheck.isString(providerClassOrName) && this.registeredProvider(providerClassOrName)){
      providerName = providerClassOrName;
    }
    else if (TypeCheck.isSubClassOf(providerClassOrName, Provider) && providerClassOrName in this._registeredProviderTypes){
      providerName = this._registeredProviderTypes[providerClassOrName];
    }

    return providerName;
  }

  /**
   * Auxiliary method that creates a middleware containing an action
   *
   * @param {string} providerName - registered provider name that contains the action
   * @param {string} actionName - registered action name which should be executed by the middleware
   * @param {boolean} [checkRestVisibility=false] - boolean telling if the visibility of the
   * action through the restful should be check. This is used when the action
   * is not visible through {@link Oca.restful}, however it's executed as {@link Oca.middleware}
   * @param {function} [responseCallback] - optional response callback that overrides
   * the default json response. The callback carries the express:
   * function(err, result, req, res, next){...}
   * @return {function}
   * @private
   */
  static _createMiddleware(providerName, actionName, checkRestVisibility=false, responseCallback=null){
    const ProviderClass = this.registeredProvider(providerName);
    assert(ProviderClass, `Provider: ${providerName} is not registered!`);

    const actionHolder = ProviderClass._actionHolder(actionName);
    assert(actionHolder, `Action: ${providerName}/${actionName} is not registered!`);

    // when the action is webfied requiring auth then creating a middleware that
    // executes the passport authentication
    let authMiddleware = null;
    if (actionHolder.info.requestAuth){
      authMiddleware = (req, res, next) => {
        // storing the request handler inside of the res.locals, so this object
        // can be accessed later by the action
        res.locals.provider = new ProviderClass(new Session(req)); // eslint-disable-line no-param-reassign
        res.locals.requestHandler = res.locals.provider.requestHandler(); // eslint-disable-line no-param-reassign
        const authenticate = res.locals.requestHandler.constructor.authenticate;

        // making sure there is authentication defined
        assert(TypeCheck.isCallable(authenticate), `Action: ${providerName}/${actionName} requires auth! (Settings.authenticate is not defined!)`);

        // executing the passport auth
        authenticate(req, res, next);
      };
    }

    // creating the middleware that executes the action
    const actionMiddleware = (req, res, next) => {

      // in case the action does not require auth we need to create a requestHandler,
      // otherwise if would be already created by the auth middleware
      if (res.locals.requestHandler === undefined){
        res.locals.provider = new ProviderClass(new Session(req)); // eslint-disable-line no-param-reassign
        res.locals.requestHandler = res.locals.provider.requestHandler(); // eslint-disable-line no-param-reassign
      }

      // creates the action
      const action = res.locals.provider.createAction(actionName);

      // executing the action middleware
      res.locals.requestHandler.executeAction(action, checkRestVisibility).then((value) => {
        // callback that handles the response (Oca.middleware)
        if (TypeCheck.isCallable(responseCallback)){
          responseCallback(null, value, req, res, next);
        }
        // restful response
        else{
          res.locals.requestHandler.render(null, value, res);
        }
      }).catch((err) => {
        // callback that handles the response (Oca.middleware)
        if (TypeCheck.isCallable(responseCallback)){
          responseCallback(err, null, req, res, next);
        }
        // restful response
        else{
          res.locals.requestHandler.render(err, null, res);
        }
      });
    };

    // returning auth + action middlewares
    if (authMiddleware){
      return (req, res, next) => {
        authMiddleware(req, res, (err) => {
          /* istanbul ignore if */
          if (err){
            next(err);
          }
          else{
            actionMiddleware(req, res, next);
          }
        });
      };
    }

    // otherwise just returns the action middleware
    return actionMiddleware;
  }

  /**
   * Clears the cache used to store the middleware functions for the webfied
   * routes
   *
   * @private
   */
  static _clearRoutesPathCache(){
    for (const route in this._routesPathCache){
      delete this._routesPathCache[route];
    }
  }

  /**
   * Returns an object that contains the action class and the extra information
   * associated with it that was defined during the registration of the action
   *
   * @param {string} actionName - name of the registered action
   * @return {Object|null}
   * @private
   */
  static _actionHolder(actionName){
    const result = this._providerActions(this, actionName);
    return result[actionName] || null;
  }

  /**
   * Returns the actions registered for the input provider class, alternatively
   * an specific action name can be supplied
   *
   * @param {Provider} provider - provider type that should be used to query the
   * actions
   * @param {string} [specificName] - registered action name
   * @return {Object}
   * @private
   */
  static _providerActions(provider, specificName=null){
    assert(TypeCheck.isSubClassOf(provider, Provider), 'Invalid provider');
    assert(specificName === null || TypeCheck.isString(specificName), 'specificName needs to be defined as string or null!');

    this._classHierarchyCache(provider);

    const actions = {};

    if (provider in this._classHierarchy){
      for (const c of this._classHierarchy[provider]){
        const providerName = this._resolveProviderName(c);

        if (providerName === null || !(providerName in this._actions)){
          continue;
        }

        if (specificName === null){
          for (const actionName in this._actions[providerName]){
            actions[actionName] = this._actions[providerName][actionName];
          }
        }
        else if (specificName in this._actions[providerName]){
          actions[specificName] = this._actions[providerName][specificName];
          return actions;
        }
      }
    }

    return actions;
  }

  /**
   * Auxiliary method that bakes a cache of subclasses which is used when querying actions
   * @param {Provider} provider - provider class that should be used to create the cache
   * @private
   */
  static _classHierarchyCache(provider){
    // getting all super classes which is used later to get the registered actions. When querying for an
    // specific if that is not available for the current class, then it should look through for that in
    // the super classes as well.
    if (!(provider in this._classHierarchy)){
      const providerClasses = [];
      let currentClass = provider;

      while (!(Object.getPrototypeOf(currentClass).name === '')){
        providerClasses.push(currentClass);
        currentClass = Object.getPrototypeOf(currentClass);
      }

      // registering the whole hierarchy individually
      for (let i = 0; i < providerClasses.length; i++){
        if (!(providerClasses[i] in this._classHierarchy)){
          this._classHierarchy[providerClasses[i]] = providerClasses.slice(i);
        }
      }
    }
  }

  static _webfyProviders = {};
  static _actions = {};
  static _classHierarchy = {};
  static _registeredProviderNames = {};
  static _registeredProviderTypes = {};
  static _routesPathCache = {};
  static _eventEmitter = new EventEmitter();
}

module.exports = Provider;
